bot_trader_rsi_ma_volume.py



# IA Trader - EstratÃ©gia com RSI, MÃ©dias MÃ³veis e Volume (Painel Interativo com Streamlit)

import pandas as pd
import matplotlib.pyplot as plt
import requests
from datetime import datetime
import streamlit as st

# FunÃ§Ã£o para calcular o RSI manualmente
def calcular_rsi(series, period=14):
    delta = series.diff()
    ganho = delta.where(delta > 0, 0)
    perda = -delta.where(delta < 0, 0)
    media_ganho = ganho.rolling(window=period).mean()
    media_perda = perda.rolling(window=period).mean()
    rs = media_ganho / media_perda
    rsi = 100 - (100 / (1 + rs))
    return rsi

# FunÃ§Ã£o para obter e processar dados
@st.cache_data
def obter_dados(ativo_id):
    url = f"https://api.coingecko.com/api/v3/coins/{ativo_id}/market_chart"
    params = {
        'vs_currency': 'usd',
        'days': '90'
    }
    response = requests.get(url, params=params)
    if response.status_code == 200 and 'prices' in response.json():
        data = response.json()['prices']
    else:
        return None

    prices = pd.DataFrame(data, columns=['Timestamp', 'Close'])
    prices['Date'] = pd.to_datetime(prices['Timestamp'], unit='ms')
    prices.set_index('Date', inplace=True)
    df = prices[['Close']]
    df['Volume'] = df['Close'].rolling(5).std() * 100
    df['RSI'] = calcular_rsi(df['Close'], period=14)
    df['MA9'] = df['Close'].rolling(window=9).mean()
    df['MA25'] = df['Close'].rolling(window=25).mean()
    df['MA50'] = df['Close'].rolling(window=50).mean()
    df['Volume_Mean'] = df['Volume'].rolling(window=20).mean()

    df['Signal'] = (
        (df['RSI'] < 40) &
        (df['MA9'] > df['MA25'])
    ).astype(int)

    df['Exit'] = (
        (df['RSI'] > 70) |
        (df['MA9'] < df['MA25'])
    ).astype(int)

    return df

# FunÃ§Ã£o para simular trades
def simular_trades(df):
    trades = []
    position = None
    for i in range(len(df)):
        if df['Signal'].iloc[i] == 1 and position is None:
            entry_price = df['Close'].iloc[i]
            entry_time = df.index[i]
            position = {'entry_time': entry_time, 'entry_price': entry_price}
        elif position and df['Exit'].iloc[i] == 1:
            exit_price = df['Close'].iloc[i]
            exit_time = df.index[i]
            profit = exit_price - position['entry_price']
            profit_pct = (profit / position['entry_price']) * 100
            trades.append({
                'entry_time': position['entry_time'],
                'entry_price': position['entry_price'],
                'exit_time': exit_time,
                'exit_price': exit_price,
                'profit': profit,
                'profit_pct': profit_pct
            })
            position = None
    return pd.DataFrame(trades)

# TÃ­tulo e seleÃ§Ã£o de ativo
st.title("ğŸ“Š IA Trader com RSI + MÃ©dias MÃ³veis + Volume")
ativos = {
    'bitcoin': 'BTC/USDT',
    'ethereum': 'ETH/USDT',
    'uniswap': 'UNI/USDT'
}
ativo_id = st.selectbox("Selecione o Ativo:", list(ativos.keys()), format_func=lambda x: ativos[x])
df = obter_dados(ativo_id)

if df is not None:
    st.subheader(f"GrÃ¡fico de {ativos[ativo_id]}")
    plt.figure(figsize=(14, 7))
    plt.plot(df['Close'], label='PreÃ§o')
    plt.plot(df['MA9'], label='MA9')
    plt.plot(df['MA25'], label='MA25')
    plt.plot(df['MA50'], label='MA50')
    plt.scatter(df[df['Signal'] == 1].index, df[df['Signal'] == 1]['Close'], label='Entrada', marker='^', color='g', s=100)
    plt.scatter(df[df['Exit'] == 1].index, df[df['Exit'] == 1]['Close'], label='SaÃ­da', marker='v', color='r', s=100)
    plt.legend()
    plt.grid(True)
    st.pyplot(plt)

    # Simular trades
    trades_df = simular_trades(df)
    st.subheader("ğŸ“ˆ Resultados dos Trades Simulados")
    st.dataframe(trades_df)

    st.metric("Lucro Total ($)", round(trades_df['profit'].sum(), 2))
    st.metric("Lucro Percentual MÃ©dio (%)", round(trades_df['profit_pct'].mean(), 2))

    csv = trades_df.to_csv(index=False).encode('utf-8')
    st.download_button(
        label="ğŸ“¥ Baixar CSV com Trades",
        data=csv,
        file_name=f"trades_{ativo_id}.csv",
        mime='text/csv'
    )
else:
    st.error("Erro ao obter dados do ativo selecionado.")
